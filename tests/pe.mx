
-- partitionEithers :: [a + b] -> [a] * [b]

A, B,
xs : mu x . 1 + ((A + B) * x),
ys : ~ (mu x . 1 + (A * x)),
zs : ~ (mu x . 1 + (B * x)),
mix : forall a . forall b . (a * b) -o (a | b) |-
let u = unfold ys in
let v = unfold zs in
let a @ s = u in
let b @ t = v in
let f, n = s in
let g, m = t in
let w = fold xs in
let x = w @ a * b in
connect via x
    { h ->
        offer i for h in
        let j,k = i in
        case j of
            { inl x ->
                let () = x in
                let f' = demand f in
                let g' = demand g in
                connect via f'
                    { i -> let i' = fst i in i'
                    ; a -> connect via g'
                        { i -> let i' = fst i in i'
                        ; b -> connect via k
                            { a' -> a <-> a'
                            ; b' -> b <-> b'
                            }
                        }
                    }
            ; inr y ->
                let AB, ab = y in
                let a, b = ab in
                case AB of
                    { inl A ->
                        let f' = demand f in
                        ignore g in
                        connect via f'
                            { i -> let i' = snd i in connect via i'
                                { A' -> A <-> A'
                                ; a' -> a <-> a'
                                }
                            ; a2 -> connect via k
                                { a' -> a2 <-> a'
                                ; b' -> b <-> b'
                                }
                            }
                    ; inr B ->
                        let g' = demand g in
                        ignore f in
                        connect via g'
                            { i -> let i' = snd i in connect via i'
                                { B' -> B <-> B'
                                ; b' -> b <-> b'
                                }
                            ; b2 -> connect via k
                                { a' -> a <-> a'
                                ; b' -> b2 <-> b'
                                }
                            }
                    }
            }
    ; z ->
        let mix' = mix @ a in
        let mix'' = mix' @ b in
        connect via mix''
            { u -> u <-> z
            ; v -> connect via v
                { n' -> n <-> n'
                ; m' -> m <-> m'
                }
            }
    }


{-
let x = w @ a | b in
connect via x
    { h ->
       offer h' for h in
       let list, a'b' = h' in
       case list of
        { inl nil ->
            let () = nil in
            let f' = demand f in
            let g' = demand g in
            let a', b' = a'b' in
            connect via f'
                { i -> let i' = fst i in i'
                ; a -> connect via g'
                    { i -> let i' = fst i in i'
                    ; b -> _
                    }
                }
        ; inr b -> _
        }
    ; z -> connect via z
        { n' -> n' <-> n
        ; m' -> m' <-> m
        }
    }
    -}

{-

            x : A, G |- a
----------------------------------
z : !A, G |- let x = demand z in a


           y : A, !G |- a
---------------------------------
z : ?A, !G |- offer y for z in a




G, u : forall a . !(F(a) -o a) -o a |- c
----------------------------------------
G, z : mu F |- let u = fold z in c

-}
